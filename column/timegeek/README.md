## note

### 变量声明
> 如果没有显式为变量赋予初值，Go 编译器会为变量赋予这个类型的零值。 整数类型是0、浮点类型是0.0 、布尔是false、指针、接口、切片、channel、map和函数是nil

![img.png](go-first-course/img/img.png)
### 区别总结空结构和空接口

- struct{} 是一个空结构体，表示一个不包含任何字段的结构体；而 interface{} 是一个空接口，表示一个不包含任何方法的接口。
- 空结构体通常用于表示不需要存储任何数据的情况，而空接口通常用于表示不限定具体类型的情况。
- 空结构体在并发编程中常用作信号或事件的通知；空接口常用于需要接收任意类型的值的场景。

> 在实际编程中，空结构体和空接口都有其特定的用途，可以根据具体情况选择使用。

### byte类型 => 字节类型

> 在 gRPC 请求中，byte 类型通常用于表示二进制数据，例如文件内容、图像数据、视频数据等。gRPC 使用 Protocol Buffers 作为默认的序列化和反序列化格式，而 Protocol Buffers 支持将二进制数据表示为字节序列。

> 在 gRPC 中，您可能会使用 byte 类型来传输二进制数据。例如，如果您有一个 gRPC 服务，需要接收一个文件作为输入，您可以将文件内容表示为 byte 类型，并在 gRPC 请求中传输这些字节。
```
// 定义 gRPC 请求消息
message UploadFileRequest {
  bytes file_content = 1;
}
// 生成的 gRPC 服务端代码
func (s *Server) UploadFile(ctx context.Context, req *pb.UploadFileRequest) (*pb.UploadFileResponse, error) {
    fileContent := req.GetFileContent()
    // 处理文件内容
    return &pb.UploadFileResponse{}, nil
}

```
### go vet
Go 官方提供了 go vet 工具可以用于对 Go 源码做一系列静态检查
```shell
go install golang.org/x/tools/go/analysis/passes/shadow/cmd/shadow@latest
go: downloading golang.org/x/tools v0.1.5
go: downloading golang.org/x/mod v0.4.2
```
我们就可以通过 go vet 扫描代码并检查这里面有没有变量遮蔽的问题

```shell
go vet -vettool=$(which shadow) -strict complex.go 
./complex.go:13:12: declaration of "err" shadows declaration at line 11
```
### 代码块与作用域(避免变量遮蔽的原则)

> 代码块有显式与隐式之分，显式代码块就是包裹在一对配对大括号内部的语句序列，而隐式代码块则不容易肉眼分辨，它是通过 Go 语言规范明确规定的。隐式代码块有五种，分别是宇宙代码块、包代码块、文件代码块、分支控制语句隐式代码块，以及 switch/select 的子句隐式代码块，理解隐式代码块是理解代码块概念以及后续作用域概念的前提与基础。

> 作用域的概念是 Go 源码编译过程中标识符（包括变量）的一个属性。Go 编译器会校验每个标识符的作用域，如果它的使用范围超出其作用域，编译器会报错。

> 不过呢，我们可以使用代码块的概念来划定每个标识符的作用域。划定原则就是声明于外层代码块中的标识符，其作用域包括所有内层代码块。但是，Go 的这种作用域划定也带来了变量遮蔽问题。简单的遮蔽问题，我们通过分析代码可以很快找出，复杂的遮蔽问题，即便是通过 go vet 这样的静态代码分析工具也难于找全。

> 因此，我们只有了解变量遮蔽问题本质，在日常编写代码时注意同名变量的声明，注意短变量声明与控制语句的结合，才能从根源上尽量避免变量遮蔽问题的发生。

### go类型系统

Go 语言的类型大体可分为：

#### 基本数据类型(整型溢出问题、整型符号位采用 2 的补码但是格式化字面值仍是用原码)：数值类型(整型、浮点型(包含科学计数)、复数类型(z=a+bi))、字符串

Go 的补码是通过原码逐位取反后再加 1 得到的，比如，我们以 -127 这个值为例，它的补码转换过程就是这样的：
![img.png](go-first-course/img/2.png)
计算机中负数用的是补码表示。 负数的补码是其绝对值取反码，再加1.

float 其实相当复杂，开发中如果能避开就避开，例如金钱单位只有美元或者人民币我建议以分作为单位或者使用decimal

#### 讲讲字符串类型的设计(go原生支持字符串: 注意区分字符串长度(go中string指字节长度)和字符长度)

- 第一点：string 类型的数据是不可变的，提高了字符串的并发安全性和存储利用率。
- 第二点：没有结尾 ’\0’， 而且获取长度的时间复杂度是常数时间，消除了获取字符串长度的开销。
- 第三点：原生支持“所见即所得”的原始字符串，大大降低构造多行字符串时的心智负担。
- 第四点：对非ASCII字符提供原生支持，消除了源码在不同环境下显示乱码的可能。

Go 语言中的字符串值也是一个可空的字节序列，字节序列中的字节个数称为该字符串的长度。

> 字符串string类型的存储：string 类型其实是一个“描述符”，它本身并不真正存储字符串数据，而仅是由一个指向底层存储的指针和字符串的长度字段组成的。

![img.png](go-first-course/img/img3.png)

> Go语言源文件默认采用的是Unicode，字符集Unicode 是一个字符编码标准，旨在为世界上所有的字符和符号提供唯一的编号（编码点），使得在不同的计算机系统和语言之间可以一致地表示和处理文本。

#### 总结
- JavaScript 中 str.length 返回的是 UTF-16 码元的数量，对于 BMP 以外的字符会返回大于实际字符数量的值。
- Go 中 len(str) 返回的是字节的数量，对于多字节字符（例如大于 U+007F 的字符）会返回大于实际字符数量的值。

> 在go语言中：单引号是表示字符、双引号是字符串、模版字符串表示所见即所得的原始字符串(一般用于多行字符串)

> 如果你需要计算实际的 Unicode 字符数量，而不是字节或码元数量，可以在两种语言中使用对应的方法。可以分别在 JavaScript 中使用 Array.from() 或 split() 方法，在 Go 中使用 []rune 转换。

#### 进制转换
- 10进制 => 八进制、十六进制、二进制 => 整数部分：除以进制数，反向取余数，直到商为0终止。小数部分：乘以进制数，取整顺序输出。
- 二进制、八进制、十六进制 => 十进制 => 二进制、八进制、十六进制转换为十进制当中的整数部分从右往左指数从0开始递增，小数部分从左往右从-1开始递减，原理都是一样的。
#### 位运算
> 位运算是计算机处理二进制数据的一种基本运算方式。它直接对整数类型的二进制表示进行操作，这种操作通常非常高效。下面是一些常见的位运算及其运算规则：

##### 常见的位运算符

按位与 (&)：

规则：对应的位都为1时，结果为1，否则为0。

示例：5 & 3 -> 0101 & 0011 -> 0001 -> 1

按位或 (|)：

规则：对应的位有一个为1时，结果为1，否则为0。

示例：5 | 3 -> 0101 | 0011 -> 0111 -> 7

按位异或 (^)：

规则：对应的位不同则为1，相同则为0。

示例：5 ^ 3 -> 0101 ^ 0011 -> 0110 -> 6

按位取反 (~)：

规则：每个位取反，0变1，1变0。

示例：^5 -> ~0101 -> 1010（按位取反后的值取决于整数的表示方式和位数）

左移 (<<)：

规则：将数字的所有位向左移动指定的位数，右侧用0填充。

示例：3 << 2 -> 0011 << 2 -> 1100 -> 12

右移 (>>)：

规则：将数字的所有位向右移动指定的位数，左侧用0（对于无符号数）或符号位的值（对于有符号数）填充。

示例：8 >> 2 -> 1000 >> 2 -> 0010 -> 2

### 复合数据类型

包括数组、切片（slice）、map、结构体，以及像 channel 这类用于并发程序设计的高级复合数据类型。

#### 数组、切片(一组连续存储的同构类型元素集合)

> 在 Go 语言中，数组（array）是基本类型，而切片（slice）是引用类型。这两个类型在内存分配和参数传递方面有显著的区别。

> 数组是值类型。将数组赋值给另一个数组或将数组作为参数传递给函数时，会复制整个数组的内容，而不是引用。因此，数组的赋值和传递都是深拷贝。

> 切片是引用类型。将切片赋值给另一个切片或将切片作为参数传递给函数时，传递的是引用，而不是复制底层数组的内容。因此，对切片的修改会影响到引用的同一个底层数组。切片包含指向底层数组的指针、长度和容量。切片可以引用数组的一部分，并且可以共享相同的底层数组。

![img.png](go-first-course/img/img4.png)
> 切片好比打开了一个访问与修改数组的“窗口”，通过这个窗口，我们可以直接操作底层数组中的部分元素。这有些类似于我们操作文件之前打开的“文件描述符”（Windows 上称为句柄），通过文件描述符我们可以对底层的真实文件进行相关操作。可以说，切片之于数组就像是文件描述符之于文件。

> 在 Go 语言中，数组更多是“退居幕后”，承担的是底层存储空间的角色。切片就是数组的“描述符”，也正是因为这一特性，切片才能在函数参数传递时避免较大性能开销。因为我们传递的并不是数组本身，而是数组的“描述符”，而这个描述符的大小是固定的（见上面的三元组结构），无论底层的数组有多大，切片打开的“窗口”长度有多长，它都是不变的。此外，我们在进行数组切片化的时候，通常省略 max，而 max 的默认值为数组的长度。

> 另外，针对一个已存在的数组，我们还可以建立多个操作数组的切片，这些切片共享同一底层数组，切片对底层数组的操作也同样会反映到其他切片中。下面是为数组 arr 建立的两个切片的内存表示：

![img.png](go-first-course/img/img5.png)

> 这里我们要清楚一个概念：切片与数组最大的不同，就在于其长度的不定长，这种不定长需要 Go 运行时提供支持，这种支持就是切片的“动态扩容”。

> “动态扩容”指的就是，当我们通过 append 操作向切片追加数据的时候，如果这时切片的 len 值和 cap 值是相等的，也就是说切片底层数组已经没有空闲空间再来存储追加的值了，Go 运行时就会对这个切片做扩容操作，来保证切片始终能存储下追加的新值。

> append 操作的这种自动扩容行为，有些时候会给我们开发者带来一些困惑，比如基于一个已有数组建立的切片，一旦追加的数据操作触碰到切片的容量上限（实质上也是数组容量的 上界)，切片就会和原数组解除“绑定”，后续对切片的任何修改都不会反映到原数组中了。这种因切片的自动扩容而导致的“绑定关系”解除，有时候会成为你实践道路上的一个小陷阱，你一定要注意这一点。

> 在大多数场合，我们都会使用切片以替代数组，原因之一是切片作为数组“描述符”的轻量性，无论它绑定的底层数组有多大，传递这个切片花费的开销都是恒定可控的；另外一个原因是切片相较于数组指针也是有优势的，切片可以提供比指针更为强大的功能，比如下标访问、边界
溢出校验、动态扩容等。而且，指针本身在 Go 语言中的功能也受到的限制，比如不支持指针算术运算。
 
> 在 Go 语言中，len 函数用于获取数组、切片、字符串、映射（map）或通道（channel）的长度。对于数组和切片，len 函数返回的是元素的数量；对于字符串，len 函数返回的是字符串的字节数，而不是字符数，需要返回字符数，使用[]rune转换。对于映射，len 函数返回的是映射中键值对的数量。 

> 在 Go 语言中，rune 是一种数据类型，表示一个 Unicode 码点。rune 本质上是一个 int32 类型，用于方便地处理 Unicode 字符。

#### map(map 是 Go 语言提供的一种抽象数据类型，它表示一组无序的键值对。)
- map 类型对 value 的类型没有限制，但是对 key 的类型却有严格要求，因为 map 类型要保证 key 的唯一性。
- Go 语言中要求，key 的类型必须支持“==”和“!=”两种比较操作符。
- 在 Go 语言中，函数类型、map 类型自身，以及切片只支持与 nil 的比较，而不支持同类型两个变量的比较。因此在这里，你一定要注意：函数类型、map 类型自身，以及切片类型是不能作为 map 的 key 类型的。

> 注意点：和切片类型变量一样，如果我们没有显式地赋予 map 变量初值，map 类型变量的默认值为 nil。

> 不过切片变量和 map 变量在这里也有些不同。初值为零值 nil 的切片类型变量，可以借助内置的 append 的函数进行操作，这种在 Go 语言中被称为“零值可用”。
但 map 类型，因为它内部实现的复杂性，无法“零值可用”。所以，如果我们对处于零值状态的 map 变量直接进行操作，就会导致运行时异常（panic），从而导致程序进程异常退出

在 Go 语言中，请使用“comma ok”惯用法对 map 进行键查找和键值读取操作。

在 Go 中，遍历 map 的键值对只有一种方法，那就是像对待切片那样通过 for range 语句对 map 数据进行遍历。

> 和切片类型一样，map 也是引用类型。这就意味着 map 类型变量作为参数被传递给函数或方法的时候，实质上传递的只是一个“描述符”（后面我们再讲这个描述符究竟是什么)，而不是整个 map 的数据拷贝，所以这个传递的开销是固定的，而且也很小。

> 和切片相比，map 类型的内部实现要更加复杂。Go 运行时使用一张哈希表(hash table)来实现抽象的 map 类型。运行时实现了 map 类型操作的所有功能，包括查找、插入、删除等。在编译阶段，Go 编译器会将 Go 语法层面的 map 操作，重写成运行时对应的函数调用。

map 类型在 Go 运行时层实现的示意图：
![img.png](go-first-course/img/img6.png)

```
1. Go语言map的基本结构

Go语言中的map底层由多个bucket组成，每个bucket存储若干个键值对。通过哈希函数将键映射到相应的bucket，然后在bucket中存储具体的键值对。

2. bucket结构

每个bucket可以存储多个键值对。在Go 1.8及之后的版本中，每个bucket最多可以存储8个键值对。一个bucket的结构大致如下：

type bmap struct {
    tophash  [8]uint8
    keys     [8]keyType
    values   [8]valueType
    overflow *bmap
}

tophash：是一个数组，存储每个键的哈希值的高8位，用于快速比较和查找。
keys：存储具体的键。
values：存储具体的值。
overflow：指向下一个bucket，用于解决哈希冲突。

3. 哈希函数

当向map中插入一个键值对时，首先会对键进行哈希计算，得到一个哈希值。哈希值的高位决定了键应该插入到哪个bucket中。

hash := hashFunc(key)
bucketIndex := hash & (len(buckets) - 1)

4. 数据存储过程

哈希计算：对键进行哈希计算得到哈希值。
定位bucket：使用哈希值的低位来确定该键值对应该插入到哪个bucket中。
存储数据：将键值对存储到对应的bucket中，并存储哈希值的高8位到tophash数组中。
处理冲突：如果一个bucket已经存满了8个键值对，那么需要分配一个新的bucket，并通过overflow指针将其链接到当前bucket上。

5. 查找过程

查找键值对时：
哈希计算：对键进行哈希计算得到哈希值。
定位bucket：使用哈希值的低位来确定应该在哪个bucket中查找。
查找匹配项：在tophash数组中查找与哈希值高8位匹配的条目，然后依次比较这些条目的键是否与目标键相等。
处理冲突：如果没有在当前bucket中找到匹配的键值对，那么顺着overflow指针查找下一个bucket，直到找到匹配项或bucket链末尾。
6. 动态扩容

当map中的键值对数量增多导致哈希冲突频繁时，map会进行扩容。扩容的步骤包括：

分配一个更大的bucket数组，通常是当前容量的两倍。
重新计算所有键的哈希值并将它们分布到新的bucket数组中。

7. 示例代码

以下是一个简单的示例代码，展示了Go语言中map的基本用法：
package main

import "fmt"

func main() {
    m := make(map[string]int)
    m["foo"] = 1
    m["bar"] = 2

    fmt.Println(m["foo"]) // 输出: 1
    fmt.Println(m["bar"]) // 输出: 2
}



```
> 每个 bucket 的 tophash 区域其实是用来快速定位 key 位置的，这样就避免了逐个 key 进行比较这种代价较大的操作。尤其是当 key 是 size 较大的字符串类型时，好处就更突出了。这是一种以空间换时间的思路。

![img.png](go-first-course/img/img7.png)

> 从上面的实现原理来看，充当 map 描述符角色的 hmap 实例自身是有状态的（hmap.flags），而且对状态的读写是没有并发保护的。所以说 map 实例不是并发写安全的，也不支持并发读写。如果我们对 map 实例进行并发读写，程序运行时就会抛出异常。

> 不过，如果我们仅仅是进行并发读，map 是没有问题的。而且，Go 1.9 版本中引入了支持并发写安全的 sync.Map 类型，可以用来在并发读写的场景下替换掉 map，如果你有这方面的需求。

> 另外，你要注意，考虑到 map 可以自动扩容，map 中数据元素的 value 位置可能在这一过程中发生变化，所以 Go 不允许获取 map 中 value 的地址，这个约束是在编译期间就生效的。

思考并实现一个方法，让我们能对 map 的进行稳定次序遍历？

思路：

> 可以用一个有序结构存储key,如slice,然后for这个slice,用key获取值。资料来源至：https://go.dev/blog/maps

> 使用链表存储可以得到有序的Map。有了描述符，再也不用担心传递性能问题了！原来多个bucket是为了降低Hash冲突，虽然一个bucket和多个bucket在查找Key时时间复杂度都是O(1)，但一个Bucket遇到Hash冲突的可能性要比多个高出很多。

> 单独对map中的key进行有序存储，然后再依据key的次序依次获取map中key对应的value.

#### struct 结构体
> 在 Go 中，提供这种聚合抽象能力的类型是结构体类型，也就是 struct。这一节课，我们就围绕着结构体的使用和内存表示，由外及里来学习 Go 中的结构体类型。

###### 结构体类型变量的初始化
> 有几种方式：零值初始化、复合字面值初始化，以及使用特定构造函数进行初始化，日常编码中最常见的是第二种。支持零值可用的结构体类型对于简化代码，改善体验具有很好的作用。另外，当复合字面值初始化无法满足要求的情况下，我们需要为结构体类型定义专门的构造函数，这种方式同样有广泛的应用。
##### 结构体类型的内存布局(https://geektutu.com/post/hpg-struct-alignment.html)

> 结构体类型是既数组类型之后，又一个以平铺形式存放在连续内存块中的类型。不过与数组类型不同，由于内存对齐的要求，结构体类型各个相邻字段间可能存在“填充物”，结构体的尾部同样可能被 Go 编译器填充额外的字节，满足结构体整体对齐的约束。正是因为这点，我们在定义结构体时，一定要合理安排字段顺序，要让结构体类型对内存空间的占用最小。

> Go 语言不支持在结构体类型定义中，递归地放入其自身类型字段，但却可以拥有自身类型的指针类型、以自身类型为元素类型的切片类型，以及以自身类型作为 value 类型的 map 类型的字段，你能思考一下其中的原因吗？

> 一个类型，它所占用的大小是固定的，因此一个结构体定义好的时候，其大小是固定的。 但是，如果结构体里面套结构体，那么在计算该结构体占用大小的时候，就会成死循环。 但如果是指针、切片、map等类型，其本质都是一个int大小(指针，4字节或者8字节，与操作系统有关)，因此该结构体的大小是固定的，记得老师前几节课讲类型的时候说过，类型就能决定内存占用的大小。
因此，结构体是可以接口自身类型的指针类型、以自身类型为元素类型的切片类型，以及以自身类型作为 value 类型的 map 类型的字段，而自己本身不行。 => 核心：因为指针、map、切片的变量元数据的内存占用大小是固定的。go是静态语言，对于一个类型，编译器要知道它的大小。如果嵌套T，那么编译器无法知道其大小。但如果是*T或[]T，编译器只需要知道指针大小以及切片这个“描述符”的大小即可。

### 控制语句(if、switch case、for)

> for range 循环形式与 for 语句经典形式差异较大，除了循环体保留了下来，其余组成部分都“不见”了。其实那几部分已经被融合到 for range 的语义中了。

> for range 对于 string 类型来说，每次循环得到的 v 值是一个 Unicode 字符码点，也就是 rune 类型值，而不是一个字节，返回的第一个值 i 为该 Unicode 字符码点的内存编码（UTF-8）的第一个字节在字符串内存序列中的位置。使用 for 经典形式与使用 for range 形式，对 string 类型进行循环操作的语义是不同的。

> 我们要对 map 进行循环操作，for range 是唯一的方法。每次循环，循环变量 k 和 v 分别会被赋值为 map 键值对集合中一个元素的 key 值和 value 值。

> channel 是 Go 语言提供的并发设计的原语，它用于多个 Goroutine 之间的通信，我们在后面的课程中还会详细讲解 channel。当 channel 类型变量作为 for range 语句的迭代对象时，for range 会尝试从 channel 中读取数据，使用形式是这样的：

```go
var c = make(chan int) 
for v := range c {
    // ... 
}
```
> 带 label 的 continue 语句，通常出现于嵌套循环语句中，被用于跳转到外层循环并继续执行外层循环语句的下一个迭代。

> 和 continue 语句一样，Go 也 break 语句增加了对 label 的支持。而且，和前面 continue 语句一样，如果遇到嵌套循环，break 要想跳出外层循环，用不带 label 的 break 是不够，因为不带 label 的 break 仅能跳出其所在的最内层循环。要想实现外层循环的跳出，我们还需给 break 加上 label。

#### for 语句的常见“坑”与避坑方法
问题一：循环变量的重用=>循环变量的值与你之前的“预期”不符
```go
// 看示例 09/bookstore/test/tst.go
func main() {
    var m = []int{1, 2, 3, 4, 5}
    for i, v := range m {
        go func() {
            time.Sleep(time.Second * 3)  
			fmt.Println(i, v)
        }
    }
    time.Sleep(time.Second * 10) // 这里的Sleep作用 => 确保所有 Goroutine 有时间完成输出
	// 在并发编程中，Goroutine 是轻量级线程，它们会在后台并发执行。当我们启动多个 Goroutine 时，它们不会阻塞主线程的执行。主线程可能会在 Goroutine 执行完成之前就退出，从而导致 Goroutine 还没来得及输出就被终止。
	// time.Sleep(time.Second * 10)作用是让主 Goroutine 休眠一段时间（这里是10秒），以确保在主 Goroutine 退出之前，所有启动的 Goroutine 有足够的时间完成它们的工作（输出内容）。
	// 为什么需要等待
    // 异步执行：Goroutine 是并发执行的，启动后会在后台运行，而主 Goroutine 会继续执行后续代码。
    // 程序退出：如果主 Goroutine 执行完毕，整个程序就会退出，无论后台的 Goroutine 是否已经完成。因此，如果不等待，可能会导致 Goroutine 还没输出结果，程序就已经结束了。
    // 解决方法
    // 在实际应用中，简单的 time.Sleep 是一种不严谨的做法，因为我们不确定确切需要等待的时间。推荐使用同步机制，如 sync.WaitGroup，确保所有 Goroutine 完成后再退出程序。
	// 使用 sync.WaitGroup
    // sync.WaitGroup 是一个用于等待一组 Goroutine 完成的同步机制。以下是如何使用它确保所有 Goroutine 完成后再退出
}
```
问题二：参与循环的是 range 表达式的副本 
> 用切片遍历可以解决数组遍历中由于副本导致修改原数组改变不生效问题？那切片是如何做到的呢？

> 切片在 Go 内部表示为一个结构体，由（array, len, cap）组成，其中 array 是指向切片对应的底层数组的指针，len 是切片当前长度，cap 为切片的最大容量。
所以，当进行 range 表达式复制时，我们实际上复制的是一个切片，也就是表示切片的结构体。表示切片副本的结构体中的 array，依旧指向原切片对应的底层数组，所以我们对切片副本的修改也都会反映到底层数组 a 上去。
而 v 再从切片副本结构体中 array 指向的底层数组中，获取数组元素，也就得到了被修改后的元素值。

问题三：遍历 map 中元素的随机性
> 如果我们在循环的过程中，对 map 进行了修改，那么这样修改的结果是否会影响后续迭代呢？这个结果和我们遍历 map 一样，具有随机性。

> 在“参与循环的是 range 表达式的副本”这一部分中，我们用切片替换了数组，实现了我们预期的输出，我想让你思考一下，除了换成切片这个方案之外，还有什么方案也能实现我们预期的输出呢？

```go
// 数组指针代替数组参与range遍历
func main() {
    var a = [5]int{1, 2, 3, 4, 5}
    var r [5]int
    fmt.Println("original a =", a)
    for i, v := range &a { //a 改为&a
        if i == 0 {
            a[1] = 12  
            a[2] = 13
        }
        r[i] = v
    }
    fmt.Println("after for range loop, r =", r)  
	fmt.Println("after for range loop, a =", a)
}
```
#### switch case
注意点： 
1. 无论 default 分支出现在什么位置，它都只会在所有 case 都没有匹配上的情况下才会被执行的。
2. switch 语句各表达式的求值结果可以为各种类型值，只要它的类型支持比较操作就可以了。
3. switch 语句支持声明临时变量。case 语句支持表达式列表。
4. 取消了默认执行下一个 case 代码逻辑的语义。 fallthrough可以继续往下执行下一个case的需求。(这里有个坑点：个人感觉fallthrough，执行完 case1 后，继续case2里面的代码，而不用判断case2的条件是否成立，这一点设计的并不好，估计很多人会理解为继续判断case2条件)
5. type switch => switch 关键字后面跟着的表达式为x.(type)，这种表达式形式是 switch 语句专有的，而且也只能在 switch 语句中使用。我们除了可以获得变量 x 的动态类型信息之外，也能获得其动态类型对应的值信息。
6. 跳不出循环的 break => 看test中的案例09/bookstore/test

### 函数一等公民

> package的作用：在 Go 语言中，包（package）是代码组织的基本单元。它不仅用于组织和管理代码，还在代码的模块化、重用、依赖管理、封装等方面发挥了重要作用。

#### 函数定义

如果忽略 Go 包在 Go 代码组织层面的作用，我们可以说 Go 程序就是一组函数的集合。

Go 不直接支持可选参数，但可以通过以下方法实现类似的功能：
- 使用可变参数（variadic parameters）
- 使用结构体封装参数
- 使用函数选项模式（functional options）

![img.png](go-first-course/img/img8.png)

> 我们看到，函数声明中的函数名其实就是变量名，函数声明中的 func 关键字、参数列表和返回值列表共同构成了函数类型。而参数列表与返回值列表的组合也被称为函数签名，它是决定
两个函数类型是否相同的决定因素。因此，函数类型也可以看成是由 func 关键字与函数签名组合而成的。

如果我们把这两个函数类型的参数名与返回值变量名省略，那它们都是func (int, string) ([]string, error)，因此它们是相同的函数类型。
到这里，我们可以得到这样一个结论：每个函数声明所定义的函数，仅仅是对应的函数类型的一个实例。
```go
s := T{} // 使用复合类型字面值对结构体类型T的变量进行显式初始化
f := func(){} // 使用变量声明形式的函数声明
// T{}被称为复合类型字面值，那么处于同样位置的 func(){}是什么呢？Go 语言也为它准备了一个名字，叫“函数字面值（Function Literal）”。我们可以看到，函数字面值由函数类型与函数体组成，它特别像一个没有函数名的函数声明，因此我们也叫它匿名函数。匿名函数在Go 中用途很广
```
#### 函数参数的那些事儿
> 在函数声明阶段，我们把参数列表中的参数叫做形式参数（Parameter，简称形参），在函数体中，我们使用的都是形参；而在函数实际调用时传入的参数被称为实际参数（Argument，简称实参）。
![img.png](go-first-course/img/img9.png)

- 函数参数的那些事儿

    > 当我们实际调用函数的时候，实参会传递给函数，并和形式参数逐一绑定，编译器会根据各个形参的类型与数量，来检查传入的实参的类型与数量是否匹配。只有匹配，程序才能继续执行函数调用，否则编译器就会报错。
    1. Go 语言中，函数参数传递采用是值传递的方式。所谓“值传递”，就是将实际参数在内存中的表示逐位拷贝（Bitwise Copy）到形式参数中。对于像整型、数组、结构体这类类型，它们的内存表示就是它们自身的数据内容，因此当这些类型作为实参类型时，值传递拷贝的就是它们自身，传递的开销也与它们自身的大小成正比。 
    2. 但是像 string、切片、map 这些类型就不是了，它们的内存表示对应的是它们数据内容的“描述符”。当这些类型作为实参类型时，值传递拷贝的也是它们数据内容的“描述符”，不包括数据内容本身，所以这些类型传递的开销是固定的，与数据内容大小无关。这种只拷贝“描述符”，不拷贝实际数据内容的拷贝过程，也被称为“浅拷贝”。 
    3. 不过函数参数的传递也有两个例外，当函数的形参为接口类型，或者形参是变长参数时，简单的值传递就不能满足要求了，这时 Go 编译器会介入：对于类型为接口类型的形参，Go 编译器会把传递的实参赋值给对应的接口类型形参；对于为变长参数的形参，Go 编译器会将零个或多个实参按一定形式转换为对应的变长形参。

- 函数支持多返回值

> Go 语言的错误处理机制很大程度就是建立在多返回值的机制之上

> Go 标准库以及大多数项目代码中的函数，都选择了使用普通的非具名返回值形式。但在一些特定场景下，具名返回值也会得到应用。比如，当函数使用 defer，而且还在 defer 函数中修改外部函数返回值时，具名返回值可以让代码显得更优雅清晰。

- 函数作为一等公民的特征(函数也是一种类型)
  - Go 函数可以存储在变量中
  - 支持在函数内创建并通过返回值返回(当外部外部将一个内部函数作为返回值返回时，内部函数使用了外部函数的变量的现象就称为闭包)
  - 作为参数传入函数
  - 拥有自己的类型(每个函数都和整型值、字符串值等一等公民一样，拥有自己的类型，也就是函数类型)
#### 如何让函数更健壮

三原则:

> 原则一：不要相信任何外部输入的参数。

> 原则二：不要忽略任何一个错误。

> 原则三：不要假定异常不会发生: 异常不是错误。错误是可预期的，也是经常会发生的，我们有对应的公开错误码和错误处理预案，但异常却是少见的、意料之外的。通常意义上的异常，指的是硬件异常、操作系统异常、语言运行时异常，还有更大可能是代码中潜在 bug 导致的异常，比如代码中出现了以 0 作为分母，或者是数组越界访问等情况。

认识 Go 语言中的异常：panic

> 不同编程语言表示异常（Exception）这个概念的语法都不相同。在 Go 语言中，异常这个概念由 panic 表示。一些教程或文章会把它译为恐慌，我这里依旧选择不译，保留 panic 的原汁原味。

> 在 Go 中，panic 主要有两类来源，一类是来自 Go 运行时，另一类则是 Go 开发人员通过 panic 函数主动触发的。无论是哪种，一旦 panic 被触发，后续 Go 程序的执行过程都是一样的，这个过程被 Go 语言称为 panicking。panicking 会沿着函数调用栈向上走,直到被捕获或者recover或者程序退出。

> recover函数：recover 是 Go 内置的专门用于恢复 panic 的函数，它必须被放在一个 defer 函数中才能生效。如果 recover 捕捉到 panic，它就会返回以 panic 的具体内容为错误上下文信息的错误值。如果没有 panic 发生，那么 recover 将返回 nil。而且，如果 panic 被 recover 捕捉到， panic 引发的 panicking 过程就会停止。

> Go 标准库提供的 http server 采用的是，每个客户端连接都使用一个单独的 Goroutine 进行处理的并发处理模型。也就是说，客户端一旦与 http server 连接成功，http server 就会为这个连接新创建一个 Goroutine，并在这 Goroutine 中执行对应连接（conn）的 serve 方法，来处理这条连接上的客户端请求。无论在哪个 Goroutine 中发生未被恢复的 panic，整个程序都将崩溃退出。所以，为了保证处理某一个客户端连接的 Goroutine 出现 panic 时，不影响到 http server 主 Goroutine 的运行，Go 标准库在 serve 方法中加入了对 panic 的捕捉与恢复，serve 方法在一开始处就设置了 defer 函数，并在该函数中捕捉并恢复了可能出现的 panic。这样，即便处理某个客户端连接的 Goroutine 出现 panic，处理其他连接 Goroutine 以及 http server 自身都不会受到影响。这种局部不要影响整体的异常处理策略，在很多并发程序中都有应用。并且，捕捉和恢复 panic 的位置通常都在子 Goroutine 的起始处，这样设置可以捕捉到后面代码中可能出现的所有 panic

> 我们可以使用 panic，部分模拟断言对潜在 bug 的提示功能。在 Go 标准库中，大多数 panic 的使用都是充当类似断言的作用的。

> 不要混淆异常与错误: 作为 API 函数的作者，你一定不要将 panic 当作错误返回给 API 调用者。

使用 defer 简化函数实现
defer 是 Go 语言提供的一种延迟调用机制，defer 的运作离不开函数。
- 在 Go 中，只有在函数（和方法）内部才能使用 defer；
- defer 关键字后面只能接函数（或方法），这些函数被称为 deferred 函数。defer 将它们注册到其所在 Goroutine 中，用于存放 deferred 函数的栈数据结构中，这些 deferred 函数将在执行 defer 的函数退出前，按后进先出（LIFO）的顺序被程序调度执行（如下图所
示）。
![img.png](go-first-course/img/img10.png)
- 无论是执行到函数体尾部返回，还是在某个错误处理分支显式 return，又或是出现 panic，已经存储到 deferred 函数栈中的函数，都会被调度执行。

defer 使用的几个注意事项 => 查看testDefer例子

- 第一点：明确哪些函数可以作为 deferred 函数(通过匿名函数的方式可以让不支持defer的内置函数支持)
- 第二点：函数返回前，deferred 函数是按照后入先出（LIFO）的顺序执行的
- 第三点：注意 defer 关键字后面表达式的求值时机(函数注册到defered调用栈时对函数参数进行求值)
- 第四点：知晓 defer 带来的性能损耗(低版本8倍左右差距,1.13版本后不断优化，1.7版本后性能只相差1.5倍左右)


### 错误处理
> 基于 Go 错误处理机制、统一的错误值类型以及错误值构造方法的基础上，Go 语言形成了多种错误处理的惯用策略，包括:
- 透明错误处理策略
- “哨兵”错误处理策略
- 错误值类型检视策略
- 错误行为特征检视策略

这些策略都有适用的场合，但没有某种单一的错误处理策略可以适合所有项目或所有场合。 

使用建议参考
- 请尽量使用“透明错误”处理策略，降低错误处理方与错误值构造方之间的耦合； 
- 如果可以通过错误值类型的特征进行错误检视，那么请尽量使用“错误行为特征检视策略”;
- 在上述两种策略无法实施的情况下，再使用“哨兵”策略和“错误值类型检视”策略； 
- Go 1.13 及后续版本中，尽量用errors.Is和errors.As函数替换原先的错误检视比较语句。

### 接口类型
区分类型、接口、方法
> 在 Go 语言中，接口、类型和方法是三个核心概念，它们分别扮演不同的角色并具有不同的用途。理解它们的区别和关系对编写清晰、模块化和可维护的代码至关重要。
1. 类型（Type）
> 类型是对一组数据和操作的抽象。在 Go 语言中，类型可以是基础类型（如 int、string）、结构体类型（struct）以及用户定义的类型。

```go
type Person struct {
    Name string
    Age  int
}
```
2. 方法（Method）
> 方法是与特定类型关联的函数。方法的接收者可以是值类型或指针类型。通过方法，可以为某个类型定义行为。
```go
func (p Person) Greet() string {
    return "Hello, my name is " + p.Name
}
```
3. 接口（Interface）
> 接口是方法的集合，定义了一组方法的签名。任何类型只要实现了接口中的所有方法，就被认为实现了该接口。接口是一种抽象类型，它描述了类型的行为，而不是具体实现。
```go
type Greeter interface {
    Greet() string
}
func sayHello(g Greeter) {
    fmt.Println(g.Greet())
}

```
4. 区别和关系
```markdown
  类型 vs. 方法

  类型 是对数据的抽象和定义。
  方法 是与类型关联的函数，定义了类型的行为。

  类型 vs. 接口

  类型 是具体的数据结构或数据的定义。
  接口 是对行为的抽象定义，规定了一组方法。

  方法 vs. 接口

  方法 是具体类型的行为实现。
  接口 是对行为的抽象描述，定义了方法的签名。
```
```go
// 完整例子
package main

import "fmt"

// 定义一个结构体类型 Person
type Person struct {
  Name string
  Age  int
}

// 为 Person 类型定义一个方法 Greet
func (p Person) Greet() string {
  return "Hello, my name is " + p.Name
}

// 定义一个接口 Greeter
type Greeter interface {
  Greet() string
}

// 定义一个函数 sayHello，接收一个 Greeter 接口
func sayHello(g Greeter) {
  fmt.Println(g.Greet())
}

func main() {
  // 创建一个 Person 类型的实例
  p := Person{Name: "Alice", Age: 30}

  // 由于 Person 类型实现了 Greeter 接口的方法，所以可以作为 Greeter 接口的实现类型传递给 sayHello 函数
  sayHello(p)
}
// 看test用例 errorTest
```
### 理解go语言中方法的本质:一个以方法的 receiver 参数作为第一个参数的普通函数。
> Go 语言从设计伊始，就不支持经典的面向对象语法元素，比如类、对象、继承，等等，但 Go 语言仍保留了名为“方法（method）”的语法元素。当然，Go 语言中的方法和面向对象中的方法并不是一样的。Go 引入方法这一元素，并不是要支持面向对象编程范式，而是 Go 践行组合设计哲学的一种实现层面的需要。

![img.png](go-first-course/img/img11.png)

> 和由五个部分组成的函数声明不同，Go 方法的声明有六个组成部分，多的一个就是图中的 receiver 部分。在 receiver 部分声明的参数，Go 称之为 receiver 参数，这个 receiver 参数也是方法与类型之间的纽带，也是方法与函数的最大不同。

> 除了 receiver 参数名字要保证唯一外，Go 语言对 receiver 参数的基类型也有约束，那就是 receiver 参数的基类型本身不能为指针类型或接口类型。

> Go 对方法声明的位置也是有约束的，Go 要求，方法声明要与 receiver 参数的基类型声明放在同一个包内。

> C++ 中的对象在调用方法时，编译器会自动传入指向对象自身的 this 指针作为方法的第一个参数。Go 方法中的原理也是相似的，只不过我们是将 receiver 参数以第一个参数的身份并入到方法的参数列表中(等价转换后的函数的类型就是方法的类型,等价转换有助于理解方法接受者是指针类型和值类型的不同)。
```go
// 案例解析
// https://tonybai.com/2018/03/20/the-analysis-of-output-results-of-a-go-code-snippet/
// https://tonybai.com/2015/09/17/7-things-you-may-not-pay-attation-to-in-go/
```
#### 如何选择 receiver 参数的类型
> 在方法中，值类型Receiver传递的是实例的副本(与函数参数的值传递一样)，因此在方法内对receiver的任意修改都不会影响原实例。而指针类型Receiver传递的是原实例的地址(与函数参数的值传递一样)，因此在方法内对receiver的任意修改都会影响原实例。

选择receiver 参数的类型的原则
- 如果 Go 方法要把对 receiver 参数代表的类型实例的修改，反映到原类型实例上，那么我们应该选择 *T 作为 receiver 参数的类型。
- 无论是 T 类型实例，还是 *T 类型实例，都既可以调用 receiver 为 T 类型的方法，也可以调用 receiver 为 *T 类型的方法。这样，我们在为方法选择 receiver 参数的类型的时候，就不需要担心这个方法不能被与 receiver 参数类型不一致的类型实例调用了。
- 如果 receiver 参数类型的 size 较大，以值拷贝形式传入就会导致较大的性能开销，这时我们选择 *T 作为 receiver 类型可能更好些。
- T 类型是否需要实现某个接口，也就是是否存在将 T 类型的变量赋值给某接口类型变量的情况。 如果 T 类型需要实现某个接口，那我们就要使用 T 作为 receiver 参数的类型，来满足接口类型方法集合中的所有方法。（这里的“T类型是否要实现接口”的含义是是否存在将T类型值赋值给接口类型的情况。）

方法集合

- Go 中任何一个类型都有属于自己的方法集合，或者说方法集合是 Go 类型的一个“属性”。但不是所有类型都有自己的方法呀，比如 int 类型就没有。所以，对于没有定义方法的 Go 类型，我们称其拥有空方法集合。
- 接口类型相对特殊，它只会列出代表接口的方法列表，不会具体定义某个方法，它的方法集合就是它的方法列表中的所有方法，我们可以一目了然地看到。
- 方法集合决定接口实现的含义就是：如果某类型 T 的方法集合与某接口类型的方法集合相同，或者类型 T 的方法集合是接口类型 I 方法集合的超集，那么我们就说这个类型 T 实现了接口 I。或者说，方法集合这个概念在 Go 语言中的主要用途，就是用来判断某个类型是否实现了某个接口。

```go
type T struct{}
func (T) M1() 
func (T) M2()
// 基于类型 T 定义了一个新类型 S
type S T
// S 类型 和 *S 类型都没有包含方法，因为type S T 定义了一个新类型。  但是如果用 type S = T 则S和*S类型都包含两个方法。
```
#### 方法：如何用类型嵌入模拟实现“继承”? 实际是组合的方式 => 通过Go 语言的类型嵌入（Type Embedding）=> 接口类型的组合以及结构体类型的类型嵌入
> 尤其要注意 *T 类型的方法集合，它包含的可不是 T1 类型的方法集合，而是 *T1 类型的方法集合。这和结构体指针类型的方法集合包含结构体类型方法集合，是一个道理。
> 类型嵌入分为两种，一种是接口类型的类型嵌入，对于接口类型的类型嵌入我们只要把握好其语义“方法集合并入”就可以了。另外一种是结构体类型的类型嵌入。通过在结构体定义中的嵌入字段，我们可以实现对嵌入类型的方法集合的“继承”。
> 种“继承”并非经典面向对象范式中的那个继承，Go 中的“继承”实际是一种组合，更具体点是组合思想下代理（delegate）模式的运用，也就是新类型代理了其嵌入类型的所有方法。当外界调用新类型的方法时，Go 编译器会首先查找新类型是否实现了这个方法，如果没有，就会将调用委派给其内部实现了这个方法的嵌入类型的实例去执行，你一定要理解这个原理。

牢记类型嵌入对新类型的方法集合的影响，包括：
- 结构体类型的方法集合包含嵌入的接口类型的方法集合。
- 当结构体类型 T 包含嵌入字段 E 时，*T 的方法集合不仅包含类型 E 的方法集合，还要包含类型 *E 的方法集合。
- 基于非接口类型的 defined 类型创建的新 defined 类型不会继承原类型的方法集合，而通过类型别名定义的新类型则和原类型拥有相同的方法集合。

```go
// 带有类型嵌入的结构体（如 S1）和不带类型嵌入的结构体（如 S2）是不等价的。带有类型嵌入的结构体能够直接调用嵌入类型的方法和访问其字段，而不带类型嵌入的结构体则需要通过字段来调用方法和访问字段。
// 这两个S1与S2是不等价的，区别是：S1结构体能调用代理嵌入类型的所有方法，S2结构体是没有代理嵌入类型方法。
type T1 int 
type t2 struct{
    n int  
	m int
}
type I interface {
    M1()
}
type S1 struct {
    T1
    *t2
    I
    a int
    b string
}
type S2 struct {
  T1 T1
  t2 *t2
  I  I
  a  int
  b  string
}
```
### 接口即契约
接口类型是由 type 和 interface 关键字定义的一组方法集合，其中，方法集合唯一确定了这个接口类型所表示的接口。
> 直接使用interface{}这个类型字面值作为所有空接口类型的代表，接口类型一旦被定义后，它就和其他 Go 类型一样可以用于声明变量
```go
/**
这些类型为接口类型的变量被称为接口类型变量，如果没有被显式赋予初值，接口类型变量的默认值为 nil。
如果要为接口类型变量显式赋予初值，我们就要为接口类型变量选择合法的右值。
 */
 */
var err error   // err是一个error接口类型的实例变量
var r io.Reader // r是一个io.Reader接口类型的实例变量
```
> Go 规定：如果一个类型 T 的方法集合是某接口类型 I 的方法集合的等价集合或超集，我们就说类型 T 实现了接口类型 I，那么类型 T 的变量就可以作为合法的右值赋值给接口类型 I 的变量。
```go
// 如果一个变量的类型是空接口类型，由于空接口类型的方法集合为空，这就意味着任何类型都实现了空接口的方法集合，
// 所以我们可以将任何类型的值作为右值，赋值给空接口类型的变量
var i interface{} = 15 // ok 
i = "hello, golang" // ok 
type T struct{}
var t T
i = t  // ok
i = &t // ok
```
> 空接口类型的这一可接受任意类型变量值作为右值的特性，让他成为 Go 加入泛型语法之前唯一一种具有“泛型”能力的语法元素，包括 Go 标准库在内的一些通用数据结构与算法的实现,都使用了空类型interface{}作为数据元素的类型，这样我们就无需为每种支持的元素类型单独做一份代码拷贝了。

> Go 语言还支持接口类型变量赋值的“逆操作”，也就是通过接口类型变量“还原”它的右值的类型与值信息，这个过程被称为“类型断言（Type Assertion）”。类型断言通常使用下面的语法形式：

> 接口类型的类型断言还有一个变种，那就是 type switch ，见switch case篇章

#### 尽量定义小接口
> 接口类型的背后，是通过把类型的行为抽象成契约，建立双方共同遵守的约定，这种契约将双方的耦合降到了最低的程度。
- 隐式契约，无需签署，自动生效(和java中需要implements显式的修饰不同)，实现者只需要实现接口方法集合中的全部方法便算是遵守了契约
- 更倾向于“小契约”，尽量定义小接口，即方法个数在 1~3 个之间的接口(也是组合的思想，大的接口类型由小的接口类型组合而成)。
  1. 第一点：接口越小，抽象程度越高(单一职责原则(SRP))
  2. 第二点：小接口易于实现和测试
  3. 第三点：小接口表示的“契约”职责单一，易于复用组合
- 尽管接口不是 Go 独有的，但专注于接口是编写强大而灵活的 Go 代码的关键。因此，在定义小接口之前，我们需要先针对问题领域进行深入理解，聚焦抽象并发现接口。先针对领域对象的行为进行抽象，形成一个接口集合：
![img.png](go-first-course/img/img12.png)
  1. 首先，别管接口大小，先抽象出接口。
  2. 第二，将大接口拆分为小接口。
  ![img.png](go-first-course/img/img13.png)
  3. 最后，我们要注意接口的单一契约职责。
> Go 接口背后的本质是一种“契约”，通过契约我们可以将代码双方的耦合降至最低。


